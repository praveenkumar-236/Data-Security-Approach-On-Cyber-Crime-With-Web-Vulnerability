"Import Libaries "
import tensorflow as tf
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn import metrics
#IMPORTING LIBRARIES
import datetime
import hashlib
import json
from tinyec import registry
from Crypto.Cipher import AES
import secrets
import hashlib, binascii
import pandas as pd
import numpy as np
#--------------------------------------------------------------------


print("==================================================")
print("KddCup Dataset")
print(" Process - DOS Attack Detection")
print("==================================================")

df= pd.read_csv('Kddcup.csv')
df.head(5)

import numpy as np

import os
  
#CREATING BLOCKCHAIN CLASS 
class Blockchain:

    def __init__(self):
        self.chain = []
        self.create_block(proof=1, previous_hash='0')

    def create_block(self, proof, previous_hash):
        block = {'index': len(self.chain) + 1,
                 'timestamp': str(datetime.datetime.now()),
                 'proof': proof,
                 'previous_hash': previous_hash}
        self.chain.append(block)
        return block
        
    def print_previous_block(self):
        return self.chain[-1]
        
    def proof_of_work(self, previous_proof):
        new_proof = 1
        check_proof = False
          
        while check_proof is False:
            hash_operation = hashlib.sha256(
                str(new_proof**2 - previous_proof**2).encode()).hexdigest()
            if hash_operation[:4] == '0000':
                check_proof = True
            else:
                new_proof += 1
                  
        return new_proof
  
    def hash(self, block):
        encoded_block = json.dumps(block, sort_keys=True).encode()
        return hashlib.sha256(encoded_block).hexdigest()
  
    def chain_valid(self, chain):
        previous_block = chain[0]
        block_index = 1
          
        while block_index < len(chain):
            block = chain[block_index]
            if block['previous_hash'] != self.hash(previous_block):
                return False
                
            previous_proof = previous_block['proof']
            proof = block['proof']
            hash_operation = hashlib.sha256(
                str(proof**2 - previous_proof**2).encode()).hexdigest()
              
            if hash_operation[:4] != '0000':
                return False
            previous_block = block
            block_index += 1
          
        return True

#ECC ENCRYTION AND DECRYPTION WITH AES
def encryption_AES(msg, secretKey):
    aesCipher = AES.new(secretKey, AES.MODE_GCM)
    ciphertext, authTag = aesCipher.encrypt_and_digest(msg)
    return (ciphertext, aesCipher.nonce, authTag)

def decryption_AES(ciphertext, nonce, authTag, secretKey):
    aesCipher = AES.new(secretKey, AES.MODE_GCM, nonce)
    plaintext = aesCipher.decrypt_and_verify(ciphertext, authTag)
    return plaintext

def ecc_to_256_bitkey(point):
    sha = hashlib.sha256(int.to_bytes(point.x, 32, 'big'))
    sha.update(int.to_bytes(point.y, 32, 'big'))
    return sha.digest()

curve = registry.get_curve('brainpoolP256r1')


def ECC_Encrytion(msg, pubKey):
    ciphertextPrivKey = secrets.randbelow(curve.field.n)
    sharedECCKey = ciphertextPrivKey * pubKey
    secretKey = ecc_to_256_bitkey(sharedECCKey)
    ciphertext, nonce, authTag = encryption_AES(msg, secretKey)
    ciphertextPubKey = ciphertextPrivKey * curve.g
    return (ciphertext, nonce, authTag, ciphertextPubKey)

def ECC_Decrytion(storedMsg, privKey):
    (ciphertext, nonce, authTag, ciphertextPubKey) = storedMsg
    sharedECCKey = privKey * ciphertextPubKey
    secretKey = ecc_to_256_bitkey(sharedECCKey)
    plaintext = decryption_AES(ciphertext, nonce, authTag, secretKey)
    return plaintext

#-------------------------------------------------------------------------------------------------
blockchain = Blockchain()
previous_block = blockchain.print_previous_block()
previous_proof = previous_block['proof']
proof = blockchain.proof_of_work(previous_proof)
previous_hash = blockchain.hash(previous_block)
block = blockchain.create_block(proof, previous_hash)

#lOADING DATASET
df=pd.read_csv('kddcup.csv')


lak = df.to_numpy().flatten()

encrypt = []
decrypt = []
for j in lak:
    j = str(j)
    msg = str.encode(j)    
    privKey = secrets.randbelow(curve.field.n)
    pubKey = privKey * curve.g
    
    encryptedMsg = ECC_Encrytion(msg, pubKey)
    encrypt.append(encryptedMsg)
      
    response = {'message': encryptedMsg,
                'index': block['index'],
                'timestamp': block['timestamp'],
                'proof': block['proof'],
                'previous_hash': block['previous_hash']} 
    response2 = {'chain': blockchain.chain,
                    'length': len(blockchain.chain)} 
    valid = blockchain.chain_valid(blockchain.chain)
          
    if valid:
        print( 'The Blockchain is valid.')
        storedMsg=response["message"]
        #print(storedMsg)
        decryptedMsg = ECC_Decrytion(storedMsg, privKey)
        decryptedMsg = decryptedMsg.decode('utf-8')
        decrypt.append(decryptedMsg)
        
        print("decrypted msg:", decryptedMsg)
    else:
        print( 'The Blockchain is not valid.')
    
"Blockchain Encryption and decryption "

def AES_Encryption(msg, secretKey):
    aesCipher = AES.new(secretKey, AES.MODE_GCM)
    ciphertext, authTag = aesCipher.encrypt_and_digest(msg)
    return (ciphertext, aesCipher.nonce, authTag)

def AES_Decryption(ciphertext, nonce, authTag, secretKey):
    aesCipher = AES.new(secretKey, AES.MODE_GCM, nonce)
    plaintext = aesCipher.decrypt_and_verify(ciphertext, authTag)
    return plaintext

def ECC_bit_key_generation(point):
    sha = hashlib.sha256(int.to_bytes(point.x, 32, 'big'))
    sha.update(int.to_bytes(point.y, 32, 'big'))
    return sha.digest()

curve = registry.get_curve('brainpoolP256r1')

def ECC_Encryption(msg, pubKey):
    ciphertextPrivKey = secrets.randbelow(curve.field.n)
    sharedECCKey = ciphertextPrivKey * pubKey
    secretKey = ECC_bit_key_generation(sharedECCKey)
    ciphertext, nonce, authTag = AES_Encryption(msg, secretKey)
    ciphertextPubKey = ciphertextPrivKey * curve.g
    return (ciphertext, nonce, authTag, ciphertextPubKey)

def ECC_Decryption(encryptedMsg, privKey):
    (ciphertext, nonce, authTag, ciphertextPubKey) = encryptedMsg
    sharedECCKey = privKey * ciphertextPubKey
    secretKey = ECC_bit_key_generation(sharedECCKey)
    plaintext = AES_Decryption(ciphertext, nonce, authTag, secretKey)
    return plaintext

#----------------------------------------------------------------------------------------


df1 = pd.read_csv("kddcup.csv") 
df1.shape

column_names = list(df.columns)

result = df.values

print("Encrypting and Decrypting the CSV file...")  
empty = []
empty_decoded = []
for i in result:
    for j in i:
        a = str(j)
        en = a.encode()
        s = ECC_Encrytion(en, pubKey)
        b = binascii.hexlify(s[0])
        encoded_text = b.decode('utf-8')
        empty.append(encoded_text)
        #print(f"Encoded Text : {encoded_text}")
        
        
        de = ECC_Decryption(s, privKey)
        decoded_text = de.decode('utf-8')
        empty_decoded.append(decoded_text)
        #print(f"Decoded Text  : {decoded_text}")
     
encrypted_df = pd.DataFrame(np.array(empty).reshape(149,4),columns = column_names)

print("Encryption Completed and written as encryption.csv file")
encrypted_df.to_csv(r'encrypted.csv',index = False)

print("decryption Completed and written as Decryption.csv file")

decrypted_df = pd.DataFrame(np.array(decrypt).reshape(149,4),columns =df.columns)
decrypted_df.to_csv(r'decryption.csv',index = False)

decrypted_df.head()  
#importing the dataset
df_train_X= pd.read_csv('decryption.csv')
df_train_y=df_train_X["label"]
df_train_X=df_train_X.iloc[:,:20]
from sklearn.preprocessing import LabelEncoder

number = LabelEncoder()

df_train_X['proto'] = number.fit_transform(df_train_X['proto'].astype(str))
df_train_X['service'] = number.fit_transform(df_train_X['service'].astype(str))
df_train_X['state'] = number.fit_transform(df_train_X['state'].astype(str))
#df_train_X['attack_cat'] = number.fit_transform(df_train_X['attack_cat'].astype(str))
print("==================================================")
print("KddCup Dataset")
print(" Preprocessing")
print("==================================================")

df_train_X.head(5)
from sklearn.model_selection import train_test_split



x_train,x_test,y_train,y_test = train_test_split(df_train_X,df_train_y,test_size = 0.30,random_state = 42)

from sklearn.ensemble import RandomForestClassifier

rf= RandomForestClassifier(n_estimators = 10)  
rf.fit(x_train, y_train)
rf_prediction = rf.predict(x_test)
Result_3=accuracy_score(y_test, rf_prediction)*100
from sklearn.metrics import confusion_matrix

print()
print("---------------------------------------------------------------------")
print("Random Forest")
print()
print(metrics.classification_report(y_test,rf_prediction))
print()
print("Random Forest Accuracy is:",Result_3,'%')
print()
print("Confusion Matrix:")
cm2=confusion_matrix(y_test, rf_prediction)
print(cm2)
print("-------------------------------------------------------")
print()
import matplotlib.pyplot as plt
import seaborn as sns

sns.heatmap(cm2, annot = True, cmap ='plasma',
        linecolor ='black', linewidths = 1)
plt.show()
from sklearn.metrics import roc_curve

fpr, tpr, _ = roc_curve(y_test, rf_prediction)
plt.plot(fpr, tpr, marker='.', label='RF')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.legend()
plt.show()



x_train=np.expand_dims(x_train, axis=2)
x_test=np.expand_dims(x_test, axis=2)
y_train=np.expand_dims(y_train,axis=1)
y_test=np.expand_dims(y_test,axis=1)


"LSTM Algorithm "
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout, Activation
from keras.layers.convolutional import Conv1D
from keras.layers.convolutional import MaxPooling1D

nb_out = 1
model = Sequential()
model.add(LSTM(input_shape=(20, 1), units=100, return_sequences=True))
model.add(Dropout(0.2))
model.add(Conv1D(filters=64, kernel_size=3, padding='same', activation='relu'))
model.add(MaxPooling1D(pool_size=2))
model.add(LSTM(units=50, return_sequences=False))
model.add(Dropout(0.2))
model.add(Dense(units=nb_out))
model.add(Activation("linear"))
model.compile(loss='mse', optimizer='sgd', metrics=['accuracy'])

print(model.summary())
# fit the model
model.fit(x_train, y_train, epochs=1, batch_size=1, verbose=1)
Result_3=model.evaluate(x_train,y_train,verbose=1)[1]*100
#from sklearn.metrics import accuracy_score
from sklearn import metrics

LSTM_prediction = model.predict(x_test)
from sklearn.metrics import confusion_matrix

print()
print("---------------------------------------------------------------------")
print(" LSTM")
print()
print(metrics.classification_report(y_test,LSTM_prediction.round()))
print()
print("LSTM  Accuracy is:",Result_3,'%')
print()
print("Confusion Matrix:")
cm2=confusion_matrix(y_test, LSTM_prediction.round())
print(cm2)
print("-------------------------------------------------------")
print()
import matplotlib.pyplot as plt
import seaborn as sns

sns.heatmap(cm2, annot = True, cmap ='plasma',
        linecolor ='black', linewidths = 1)
plt.show()
from sklearn.metrics import roc_curve
fpr, tpr, _ = roc_curve(y_test, LSTM_prediction.round())
plt.plot(fpr, tpr, marker='.', label='Hybird CNNLSTM')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.legend()
plt.show()



#for i in range (len(rf_prediction)):
#    if (rf_prediction[i] ==True ):
#        print("Attack ")
#    else:
#        print("Not Attack")
    
inp=int(input('Enter the Attack id'))
if (rf_prediction[inp] ==True ):
    print("Attack ")
else:
    print("Not Attack")
    
data1=df[df['attack_cat'].str.contains('DoS')]
 
   
#import smtplib, ssl
#
#port = 587  # For starttls
#smtp_server = "smtp.gmail.com"
#sender_email = "shanvb18@gmail.com"
#receiver_email = "shanvb18@gmail.com"
#print("Mail Passord")
#password = input("Enter Your Mail Password:")
#message =file = data1
#
#context = ssl.create_default_context()
#with smtplib.SMTP(smtp_server, port) as server:
#    server.ehlo()  # Can be omitted
#    server.starttls(context=context)
#    server.ehlo()  # Can be omitted
#    server.login(sender_email, password)
#    server.sendmail(sender_email, receiver_email, message)
#print("Sending the mail Successfully")     
#    